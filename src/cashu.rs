use std::{collections::BTreeMap, str::FromStr};

use anyhow::{Context, Result, anyhow, bail};
use base64::{
    Engine as _, alphabet,
    engine::{
        DecodePaddingMode, GeneralPurpose, GeneralPurposeConfig, general_purpose::URL_SAFE_NO_PAD,
    },
};
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use serde_bytes::ByteBuf;

use crypto::{PublicKey, Secret, SecretKey, hash_to_curve};

use crate::cashu::crypto::hash_e;

pub mod crypto;
pub mod types;

/// Blinded secret message B_
#[derive(Debug, Clone, Serialize)]
pub struct BlindedSecret(String);

impl BlindedSecret {
    pub fn from_bytes(secret_msg: &[u8]) -> Result<(Self, SecretKey)> {
        let r = SecretKey::generate();
        let b_ = Self::blind(secret_msg, &r)?;
        Ok((b_, r))
    }

    fn blind(secret_msg: &[u8], blinding_factor: &SecretKey) -> Result<Self> {
        // Y = hash_to_curve(x)
        let y = hash_to_curve(secret_msg)?;
        // Y + rG
        let b_ = y.combine(&blinding_factor.public_key())?;

        Ok(BlindedSecret(b_.to_string()))
    }
}

impl std::fmt::Display for BlindedSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// C_ blind signature (on B_)
#[derive(Debug, Clone, Deserialize)]
pub struct BlindedKey(String);

impl BlindedKey {
    pub fn unblind(self, blinding_factor: &SecretKey, pubkey: &PublicKey) -> Result<PublicKey> {
        let c_ = PublicKey::from_hex(self.0)?;
        let r = blinding_factor;

        // rK
        let rk = pubkey.to_owned().mul_tweak(r)?;
        // C = C_ - rK
        let c = c_.combine(&rk.negate())?;

        Ok(c)
    }
}

impl std::fmt::Display for BlindedKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// An encrypted ("blinded") secret and an amount is sent from Alice to Mint for minting tokens or for swapping tokens.
/// A BlindedMessage is also called an _output_.
#[derive(Debug, Clone, Serialize)]
pub struct BlindedMessage {
    amount: u64,
    /// requested keyset ID from which we expect a signature
    #[serde(rename = "id")]
    keyset_id: String,
    /// blinded secret message generated by Alice
    #[serde(rename = "B_")]
    b_: BlindedSecret,
}

impl BlindedMessage {
    pub fn new(amount: u64, keyset_id: &str, b_: BlindedSecret) -> Self {
        Self {
            amount,
            keyset_id: keyset_id.to_owned(),
            b_,
        }
    }
}

/// A BlindSignature is sent from Mint to Alice after minting tokens or after swapping tokens.
/// A BlindSignature is also called a _promise_.
#[derive(Debug, Deserialize)]
pub struct BlindSignature {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    #[serde(rename = "id")]
    keyset_id: String,
    /// blinded signature on the secret message B_ sent in the previous step
    #[serde(rename = "C_")]
    c_: BlindedKey,
    /// Discrete Log Equality (DLEQ) proof (NUT-12). Mint returns the DLEQ proof for a mint or swap operation.
    dleq: Option<Dleq>,
}

impl BlindSignature {
    pub fn construct_proof(
        &self,
        r: &SecretKey,
        amount_pubkey: &PublicKey,
        secret: &Secret,
    ) -> Result<Proof> {
        let c_ = self.c_.clone();

        let proof_dleq = if let Some(promise_dleq) = self.dleq.clone() {
            Some(DleqProof {
                e: promise_dleq.e,
                s: promise_dleq.s,
                r: r.to_string(),
            })
        } else {
            None
        };

        Ok(Proof {
            amount: self.amount,
            keyset_id: self.keyset_id.clone(),
            secret: secret.to_string(),
            c: c_
                .unblind(r, amount_pubkey)
                .context("unblind signature")?
                .to_string(),
            dleq: proof_dleq,
        })
    }
}

/// Discrete Log Equality (DLEQ) proof (NUT-12). Mint returns the DLEQ proof for a mint or swap operation.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Dleq {
    e: String,
    s: String,
}

#[derive(Debug, Deserialize)]
pub struct BlindSignatures {
    pub signatures: Vec<BlindSignature>,
}

impl BlindSignatures {
    pub fn validate_dleq(
        &self,
        outputs: &[BlindedMessage],
        active_keys: &BTreeMap<u64, String>,
    ) -> Result<bool> {
        // R1 = s*G - e*K
        // R2 = s*B' - e*C'
        // e == hash(R1,R2,A,C') # must be True

        if self.signatures.len() != outputs.len() {
            bail!("Returned signatures count does not match sent blinded messages count");
        }

        for (i, signature) in self.signatures.iter().enumerate() {
            if let Some(dleq) = &signature.dleq {
                let amount = signature.amount;
                let amount_key = active_keys
                    .get(&amount)
                    .ok_or_else(|| anyhow!("Mint error: key for amount does not exist"))?;

                let k = PublicKey::from_hex(amount_key).context("'K' pubkey")?;

                let bm = &outputs[i];
                let b = PublicKey::from_hex(bm.b_.to_string()).context("'B' pubkey")?;

                let c_ = signature.c_.to_string();
                let c = PublicKey::from_hex(&c_).context("'B' pubkey")?;

                let e = SecretKey::from_hex(&dleq.e).context("'e' secret key")?;
                let s = SecretKey::from_hex(&dleq.s).context("'s' secret key")?;

                // R1 = s*G - e*K = S - e*K
                let r1 = &s.public_key().combine(&k.mul_tweak(&e)?.negate())?.to_hex();

                // R2 = s*B' - e*C'
                let r2 = &b
                    .mul_tweak(&s)?
                    .combine(&c.mul_tweak(&e)?.negate())?
                    .to_hex();

                let computed_e = hash_e(r1, r2, &k.to_hex(), &c_).context("hash_e")?;

                if dleq.e != computed_e {
                    bail!(
                        "DLEQ validation mismatch! Expected {}; got {}",
                        computed_e,
                        dleq.e
                    )
                }
            }
        }

        Ok(true)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    #[serde(rename = "id")]
    pub keyset_id: String,
    /// secret message
    secret: String,
    /// unblinded signature on secret
    #[serde(rename = "C")]
    c: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    dleq: Option<DleqProof>,
}

impl Proof {
    pub fn remove_dleq(&mut self) {
        self.dleq = None
    }
}

/// Discrete Log Equality (DLEQ) proof (NUT-12). Mint returns the DLEQ proof for a mint or swap operation.
/// If we want to send the proof to another user we also need to include the blinding factor r for the proof to be convincing to another user.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct DleqProof {
    e: String,
    s: String,
    r: String, // We also need to include the blinding factor r for the proof to be convincing to another user
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct TokenV4 {
    #[serde(rename = "t")]
    tokens: Vec<InnerToken>,
    #[serde(rename = "m")]
    mint_url: String,
    #[serde(rename = "u")]
    unit: String,
}

impl std::fmt::Display for TokenV4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.serialize())
    }
}

impl FromStr for TokenV4 {
    type Err = anyhow::Error;

    fn from_str(token_string: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(token_string)
    }
}

impl TokenV4 {
    pub fn new(mint_url: &str, unit: &str, proofs: &[Proof]) -> Result<Self> {
        let mut keyset_id_proofs = IndexMap::<String, Vec<TokenProof>>::new();

        for proof in proofs {
            let keyset_id = proof.keyset_id.clone();
            let token_proof = TokenProof::try_from(proof)?;

            keyset_id_proofs
                .entry(keyset_id)
                .and_modify(|tp| tp.push(token_proof))
                .or_insert(vec![proof.try_into()?]);
        }

        let mut tokens = vec![];

        for (keyset_id, token_proofs) in keyset_id_proofs {
            let inner_token = InnerToken {
                keyset_id: hex::decode(keyset_id)
                    .context("decode hex value of keyset id")?
                    .into(),
                proofs: token_proofs,
            };
            tokens.push(inner_token);
        }

        Ok(Self {
            mint_url: mint_url.to_string(),
            unit: unit.to_string(),
            tokens,
        })
    }

    fn serialize(&self) -> String {
        let mut cbor_token = vec![];
        ciborium::into_writer(self, &mut cbor_token).unwrap();

        let url_encoded = URL_SAFE_NO_PAD.encode(cbor_token);
        let token_string = format!("cashuB{}", url_encoded);

        token_string
    }

    fn deserialize(token_string: &str) -> Result<Self> {
        let indifferent_padding_config =
            GeneralPurposeConfig::new().with_decode_padding_mode(DecodePaddingMode::Indifferent);
        let indifferent_padding_engine =
            GeneralPurpose::new(&alphabet::URL_SAFE, indifferent_padding_config);

        let token_string = token_string
            .strip_prefix("cashuB")
            .ok_or(anyhow!("Missing cashu version prefix"))?;
        let url_decoded = indifferent_padding_engine
            .decode(token_string)
            .context("url decode")?;
        let token = ciborium::from_reader(&url_decoded[..]).context("deserialize CBOR")?;
        Ok(token)
    }

    pub fn amount(&self) -> u64 {
        self.tokens.iter().map(|t| t.amount()).sum()
    }

    pub fn mint_url(&self) -> &str {
        &self.mint_url
    }

    pub fn proofs(&self) -> Vec<Proof> {
        let mut proofs = vec![];

        for inner_token in self.tokens.iter() {
            let keyset_id = hex::encode(inner_token.keyset_id.clone());
            for token_proof in inner_token.proofs.iter() {
                let proof = Proof {
                    amount: token_proof.amount,
                    keyset_id: keyset_id.clone(),
                    secret: token_proof.secret.clone(),
                    c: hex::encode(token_proof.c.clone()),
                    dleq: None,
                };
                proofs.push(proof);
            }
        }

        proofs
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
struct InnerToken {
    #[serde(rename = "i")]
    // keyset id represented as bytes
    pub keyset_id: ByteBuf,

    #[serde(rename = "p")]
    proofs: Vec<TokenProof>,
}

impl InnerToken {
    pub fn amount(&self) -> u64 {
        self.proofs.iter().map(|p| p.amount).sum()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
struct TokenProof {
    #[serde(rename = "a")]
    pub amount: u64,
    #[serde(rename = "s")]
    secret: String,
    // unblinded signature on secret represented as bytes
    c: ByteBuf,
}

impl TryFrom<Proof> for TokenProof {
    type Error = anyhow::Error;

    fn try_from(value: Proof) -> std::result::Result<Self, Self::Error> {
        Ok(Self {
            amount: value.amount,
            secret: value.secret,
            c: hex::decode(value.c)
                .context("decode hex value of signature in proof")?
                .into(),
        })
    }
}

impl TryFrom<&Proof> for TokenProof {
    type Error = anyhow::Error;

    fn try_from(value: &Proof) -> std::result::Result<Self, Self::Error> {
        let value = value.clone();
        value.try_into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TOKEN_STRING: &str = "cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA";

    fn prepare_token() -> TokenV4 {
        let proof1 = Proof {
            amount: 1,
            keyset_id: "00ffd48b8f5ecf80".to_string(),
            secret: "acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388".to_string(),
            c: "0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf".to_string(),
            dleq: None,
        };

        let proof2 = Proof {
            amount: 2,
            keyset_id: "00ad268c4d1f5826".to_string(),
            secret: "1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee".to_string(),
            c: "023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d".to_string(),
            dleq: None,
        };

        let proof3 = Proof {
            amount: 1,
            keyset_id: "00ad268c4d1f5826".to_string(),
            secret: "56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57".to_string(),
            c: "0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63".to_string(),
            dleq: None,
        };

        let mint_url = "http://localhost:3338";
        let unit = "sat";

        let proofs = vec![proof1, proof2, proof3];

        TokenV4::new(mint_url, unit, &proofs).unwrap()
    }

    #[test]
    fn test_token_serialization() {
        let token = prepare_token();

        let expected = TOKEN_STRING;

        assert_eq!(token.to_string(), expected);
    }

    #[test]
    fn test_token_deserialization() {
        let expected = prepare_token();

        let deserialized_token = TokenV4::from_str(TOKEN_STRING).unwrap();
        assert_eq!(deserialized_token, expected);
    }

    #[test]
    fn test_token_with_padding_deserialization() {
        let expected = prepare_token();

        let token_with_padding = &format!("{}{}", TOKEN_STRING, "==");

        let deserialized_token = TokenV4::from_str(token_with_padding).unwrap();
        assert_eq!(deserialized_token, expected);
    }

    #[test]
    fn test_validate_dleq() {
        // https://github.com/cashubtc/nuts/blob/main/tests/12-tests.md#dleq-verification-on-blindsignature
        /*
          A: "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
          B_: "02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2"

        {
          "amount": 8,
          "id": "00882760bfa2eb41",
          "C_": "02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2",
          "dleq": {
            "e": "9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73d9",
            "s": "9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73da"
          }
        }
        */

        let k = "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798".to_string();
        let b_ = "02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2".to_string();

        let id = "00882760bfa2eb41".to_string();

        let signature = BlindSignature {
            amount: 8,
            keyset_id: id.clone(),
            c_: BlindedKey(
                "02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2".to_string(),
            ),
            dleq: Some(Dleq {
                e: "9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73d9".to_string(),
                s: "9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73da".to_string(),
            }),
        };

        let active_keys: BTreeMap<u64, String> = BTreeMap::from([(8, k)]);
        let outputs = vec![BlindedMessage {
            amount: 8,
            keyset_id: id,
            b_: BlindedSecret(b_),
        }];

        let signatures = BlindSignatures {
            signatures: vec![signature],
        };

        assert!(signatures.validate_dleq(&outputs, &active_keys).unwrap());
    }
}
