use std::str::FromStr;

use anyhow::{Context, Result, anyhow};
use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use serde_bytes::ByteBuf;

use crypto::{PublicKey, Secret, SecretKey, hash_to_curve};

pub mod crypto;
pub mod types;

/// Blinded secret message B_
#[derive(Debug, Clone, Serialize)]
pub struct BlindedSecret(String);

impl BlindedSecret {
    pub fn from_bytes(secret_msg: &[u8]) -> Result<(Self, SecretKey)> {
        let r = SecretKey::generate();
        let b_ = Self::blind(secret_msg, &r)?;
        Ok((b_, r))
    }

    fn blind(secret_msg: &[u8], blinding_factor: &SecretKey) -> Result<Self> {
        // Y = hash_to_curve(x)
        let y = hash_to_curve(secret_msg)?;
        // Y + rG
        let b_ = y.combine(&blinding_factor.public_key())?;

        Ok(BlindedSecret(b_.to_string()))
    }
}

/// C_ blind signature (on B_)
#[derive(Debug, Clone, Deserialize)]
pub struct BlindedKey(String);

impl BlindedKey {
    pub fn unblind(self, blinding_factor: &SecretKey, pubkey: &PublicKey) -> Result<PublicKey> {
        let c_ = PublicKey::from_hex(self.0)?;
        let r = blinding_factor;

        // rK
        let rk = pubkey.to_owned().mul_tweak(r)?;
        // C = C_ - rK
        let c = c_.combine(&rk.negate())?;

        Ok(c)
    }
}

/// An encrypted ("blinded") secret and an amount is sent from Alice to Mint for minting tokens or for swapping tokens.
/// A BlindedMessage is also called an _output_.
#[derive(Debug, Clone, Serialize)]
pub struct BlindedMessage {
    amount: u64,
    /// requested keyset ID from which we expect a signature
    #[serde(rename = "id")]
    keyset_id: String,
    /// blinded secret message generated by Alice
    #[serde(rename = "B_")]
    b_: BlindedSecret,
}

impl BlindedMessage {
    pub fn new(amount: u64, keyset_id: &str, b_: BlindedSecret) -> Self {
        Self {
            amount,
            keyset_id: keyset_id.to_owned(),
            b_,
        }
    }
}

/// A BlindSignature is sent from Bob to Alice after minting tokens or after swapping tokens.
/// A BlindSignature is also called a _promise_.
#[derive(Debug, Deserialize)]
pub struct BlindSignature {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    #[serde(rename = "id")]
    keyset_id: String,
    /// blinded signature on the secret message B_ sent in the previous step
    #[serde(rename = "C_")]
    c_: BlindedKey,
}

impl BlindSignature {
    pub fn construct_proof(
        &self,
        r: &SecretKey,
        amount_pubkey: &PublicKey,
        secret: &Secret,
    ) -> Result<Proof> {
        let c_ = self.c_.clone();

        Ok(Proof {
            amount: self.amount,
            keyset_id: self.keyset_id.clone(),
            secret: secret.to_string(),
            c: c_
                .unblind(r, amount_pubkey)
                .context("unblind signature")?
                .to_string(),
        })
    }
}

#[derive(Debug, Deserialize)]
pub struct BlindSignatures {
    pub signatures: Vec<BlindSignature>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    #[serde(rename = "id")]
    pub keyset_id: String,
    /// secret message
    secret: String,
    /// unblinded signature on secret
    #[serde(rename = "C")]
    c: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct TokenV4 {
    #[serde(rename = "t")]
    tokens: Vec<InnerToken>,
    #[serde(rename = "m")]
    mint_url: String,
    #[serde(rename = "u")]
    unit: String,
}

impl std::fmt::Display for TokenV4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.serialize())
    }
}

impl FromStr for TokenV4 {
    type Err = anyhow::Error;

    fn from_str(token_string: &str) -> std::result::Result<Self, Self::Err> {
        Self::deserialize(token_string)
    }
}

impl TokenV4 {
    pub fn new(mint_url: &str, unit: &str, proofs: &[Proof]) -> Self {
        let mut keyset_id_proofs = IndexMap::<String, Vec<TokenProof>>::new();

        for proof in proofs {
            let keyset_id = proof.keyset_id.clone();
            keyset_id_proofs
                .entry(keyset_id)
                .and_modify(|tp| tp.push(proof.into()))
                .or_insert(vec![proof.into()]);
        }

        let mut tokens = vec![];

        for (keyset_id, token_proofs) in keyset_id_proofs {
            let inner_token = InnerToken {
                keyset_id: hex::decode(keyset_id).unwrap().into(), // TODO
                proofs: token_proofs,
            };
            tokens.push(inner_token);
        }

        Self {
            mint_url: mint_url.to_string(),
            unit: unit.to_string(),
            tokens,
        }
    }

    fn serialize(&self) -> String {
        let mut cbor_token = vec![];
        ciborium::into_writer(self, &mut cbor_token).unwrap();

        let url_encoded = URL_SAFE_NO_PAD.encode(cbor_token);
        let token_string = format!("cashuB{}", url_encoded.trim_end_matches('='));

        token_string
    }

    fn deserialize(token_string: &str) -> Result<Self> {
        let token_string = token_string
            .strip_prefix("cashuB")
            .ok_or(anyhow!("Missing cashu version prefix"))?;
        let url_decoded = URL_SAFE_NO_PAD.decode(token_string).context("url decode")?;
        let token = ciborium::from_reader(&url_decoded[..]).context("deserialize CBOR")?;
        Ok(token)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
struct InnerToken {
    #[serde(rename = "i")]
    // keyset id represented as bytes
    pub keyset_id: ByteBuf,

    #[serde(rename = "p")]
    proofs: Vec<TokenProof>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
struct TokenProof {
    #[serde(rename = "a")]
    pub amount: u64,
    #[serde(rename = "s")]
    secret: String,
    // unblinded signature on secret represented as bytes
    c: ByteBuf,
}

impl From<Proof> for TokenProof {
    fn from(value: Proof) -> Self {
        Self {
            amount: value.amount,
            secret: value.secret,
            c: hex::decode(value.c).unwrap().into(), // TODO
        }
    }
}

impl From<&Proof> for TokenProof {
    fn from(value: &Proof) -> Self {
        let value = value.clone();
        value.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TOKEN_STRING: &str = "cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA";

    fn prepare_token() -> TokenV4 {
        let proof1 = Proof {
            amount: 1,
            keyset_id: "00ffd48b8f5ecf80".to_string(),
            secret: "acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388".to_string(),
            c: "0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf".to_string(),
        };

        let proof2 = Proof {
            amount: 2,
            keyset_id: "00ad268c4d1f5826".to_string(),
            secret: "1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee".to_string(),
            c: "023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d".to_string(),
        };

        let proof3 = Proof {
            amount: 1,
            keyset_id: "00ad268c4d1f5826".to_string(),
            secret: "56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57".to_string(),
            c: "0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63".to_string(),
        };

        let mint_url = "http://localhost:3338";
        let unit = "sat";

        let proofs = vec![proof1, proof2, proof3];

        TokenV4::new(mint_url, unit, &proofs)
    }

    #[test]
    fn test_token_serialization() {
        let token = prepare_token();

        let expected = TOKEN_STRING;

        assert_eq!(token.to_string(), expected);
    }

    #[test]
    fn test_token_deserialization() {
        let expected = prepare_token();

        let deserialized_token = TokenV4::from_str(TOKEN_STRING).unwrap();
        assert_eq!(deserialized_token, expected);
    }
}
