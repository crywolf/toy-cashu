use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

use crypto::{PublicKey, Secret, SecretKey, hash_to_curve};

pub mod crypto;
pub mod types;

/// Blinded secret message B_
#[derive(Debug, Clone, Serialize)]
pub struct BlindedSecret(String);

impl BlindedSecret {
    pub fn from_bytes(secret_msg: &[u8]) -> Result<(Self, SecretKey)> {
        let r = SecretKey::generate();
        let b_ = Self::blind(secret_msg, &r)?;
        Ok((b_, r))
    }

    fn blind(secret_msg: &[u8], blinding_factor: &SecretKey) -> Result<Self> {
        // Y = hash_to_curve(x)
        let y = hash_to_curve(secret_msg)?;
        // Y + rG
        let b_ = y.combine(&blinding_factor.public_key())?;

        Ok(BlindedSecret(b_.to_string()))
    }
}

/// C_ blind signature (on B_)
#[derive(Debug, Clone, Deserialize)]
pub struct BlindedKey(String);

impl BlindedKey {
    pub fn unblind(self, blinding_factor: &SecretKey, pubkey: &PublicKey) -> Result<PublicKey> {
        let c_ = PublicKey::from_hex(self.0)?;
        let r = blinding_factor;

        // rK
        let rk = pubkey.to_owned().mul_tweak(r)?;
        // C = C_ - rK
        let c = c_.combine(&rk.negate())?;

        Ok(c)
    }
}

/// An encrypted ("blinded") secret and an amount is sent from Alice to Mint for minting tokens or for swapping tokens.
/// A BlindedMessage is also called an _output_.
#[derive(Debug, Clone, Serialize)]
pub struct BlindedMessage {
    amount: u64,
    /// requested keyset ID from which we expect a signature
    id: String,
    /// blinded secret message generated by Alice
    #[serde(rename = "B_")]
    b_: BlindedSecret,
}

impl BlindedMessage {
    pub fn new(amount: u64, keyset_id: &str, b_: BlindedSecret) -> Self {
        Self {
            amount,
            id: keyset_id.to_owned(),
            b_,
        }
    }
}

/// A BlindSignature is sent from Bob to Alice after minting tokens or after swapping tokens.
/// A BlindSignature is also called a _promise_.
#[derive(Debug, Deserialize)]
pub struct BlindSignature {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    id: String,
    /// blinded signature on the secret message B_ sent in the previous step
    #[serde(rename = "C_")]
    c_: BlindedKey,
}

impl BlindSignature {
    pub fn construct_proof(
        &self,
        r: &SecretKey,
        amount_pubkey: &PublicKey,
        secret: &Secret,
    ) -> Result<Proof> {
        let c_ = self.c_.clone();

        Ok(Proof {
            amount: self.amount,
            id: self.id.clone(),
            secret: secret.to_string(),
            c: c_
                .unblind(r, amount_pubkey)
                .context("unblind signature")?
                .to_string(),
        })
    }
}

#[derive(Debug, Deserialize)]
pub struct BlindSignatures {
    pub signatures: Vec<BlindSignature>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub amount: u64,
    /// keyset ID of the mint keys that signed the token
    id: String,
    // secret message
    secret: String,
    /// unblinded signature on secret
    #[serde(rename = "C")]
    c: String,
}
